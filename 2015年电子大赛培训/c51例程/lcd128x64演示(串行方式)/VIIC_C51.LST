C51 COMPILER V6.23a  VIIC_C51                                                              03/28/2011 00:21:22 PAGE 1   


C51 COMPILER V6.23a, COMPILATION OF MODULE VIIC_C51
OBJECT MODULE PLACED IN VIIC_C51.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE VIIC_C51.C BROWSE DEBUG OBJECTEXTEND

stmt level    source

   1          /********************************************************************
   2                                 VIIC_C51.C
   3            此程序是I2C操作平台（主方式的软件平台）的底层的C子程序,如发送数据
   4          及接收数据,应答位发送,并提供了几个直接面对器件的操作函数，它很方便的
   5          与用户程序连接并扩展.....  
   6            
   7              注意:函数是采用软件延时的方法产生SCL脉冲,固对高晶振频率要作 
   8          一定的修改....(本例是1us机器周期,即晶振频率要小于12MHZ)
   9          
  10          ********************************************************************/
  11            
  12            
  13                        
  14          #include <reg52.h>          /*头文件的包含*/
  15          #include <intrins.h>
  16          
  17          #define  uchar unsigned char /*宏定义*/
  18          #define  uint  unsigned int
  19          
  20          #define  _Nop()  _nop_()        /*定义空指令*/
  21          
  22          /* 常,变量定义区 */
  23           
  24                                                           /*端口位定义*/
  25          sbit SDA=P1^5;            /*模拟I2C数据传送位*/
  26          sbit SCL=P1^4;            /*模拟I2C时钟控制位*/
  27          
  28                                                           /*状态标志*/
  29          bit ack;                 /*应答标志位*/
  30             
  31          
  32          
  33          
  34          
  35          
  36          /*******************************************************************
  37                               起动总线函数               
  38          函数原型: void  Start_I2c();  
  39          功能:       启动I2C总线,即发送I2C起始条件.
  40            
  41          ********************************************************************/
  42          void Start_I2c()
  43          {
  44   1        SDA=1;   /*发送起始条件的数据信号*/
  45   1        _Nop();
  46   1        SCL=1;
  47   1        _Nop();    /*起始条件建立时间大于4.7us,延时*/
  48   1        _Nop();
  49   1        _Nop();
  50   1        _Nop();
  51   1        _Nop();    
  52   1        SDA=0;   /*发送起始信号*/
  53   1        _Nop();    /* 起始条件锁定时间大于4μs*/
  54   1        _Nop();
  55   1        _Nop();
C51 COMPILER V6.23a  VIIC_C51                                                              03/28/2011 00:21:22 PAGE 2   

  56   1        _Nop();
  57   1        _Nop();       
  58   1        SCL=0;   /*钳住I2C总线，准备发送或接收数据 */
  59   1        _Nop();
  60   1        _Nop();
  61   1      }
  62          
  63          
  64          
  65          
  66          /*******************************************************************
  67                                结束总线函数               
  68          函数原型: void  Stop_I2c();  
  69          功能:       结束I2C总线,即发送I2C结束条件.
  70            
  71          ********************************************************************/
  72          void Stop_I2c()
  73          {
  74   1        SDA=0;  /*发送结束条件的数据信号*/
  75   1        _Nop();   /*发送结束条件的时钟信号*/
  76   1        SCL=1;  /*结束条件建立时间大于4μs*/
  77   1        _Nop();
  78   1        _Nop();
  79   1        _Nop();
  80   1        _Nop();
  81   1        _Nop();
  82   1        SDA=1;  /*发送I2C总线结束信号*/
  83   1        _Nop();
  84   1        _Nop();
  85   1        _Nop();
  86   1        _Nop();
  87   1      }
  88          
  89          
  90          
  91          
  92          /*******************************************************************
  93                           字节数据传送函数               
  94          函数原型: void  SendByte(uchar c);
  95          功能:  将数据c发送出去,可以是地址,也可以是数据,发完后等待应答,并对
  96               此状态位进行操作.(不应答或非应答都使ack=0 假)     
  97               发送数据正常，ack=1; ack=0表示被控器无应答或损坏。
  98          ********************************************************************/
  99          void  SendByte(uchar c)
 100          {
 101   1       uchar BitCnt;
 102   1       
 103   1       for(BitCnt=0;BitCnt<8;BitCnt++)  /*要传送的数据长度为8位*/
 104   1          {
 105   2           if((c<<BitCnt)&0x80)SDA=1;   /*判断发送位*/
 106   2             else  SDA=0;                
 107   2           _Nop();
 108   2           SCL=1;               /*置时钟线为高，通知被控器开始接收数据位*/
 109   2            _Nop(); 
 110   2            _Nop();               /*保证时钟高电平周期大于4μs*/
 111   2            _Nop();
 112   2            _Nop();
 113   2            _Nop();         
 114   2           SCL=0; 
 115   2          }
 116   1          
 117   1          _Nop();
C51 COMPILER V6.23a  VIIC_C51                                                              03/28/2011 00:21:22 PAGE 3   

 118   1          _Nop();
 119   1          SDA=1;               /*8位发送完后释放数据线，准备接收应答位*/
 120   1          _Nop();
 121   1          _Nop();   
 122   1          SCL=1;
 123   1          _Nop();
 124   1          _Nop();
 125   1          _Nop();
 126   1          if(SDA==1)ack=0;     
 127   1             else ack=1;        /*判断是否接收到应答信号*/
 128   1          SCL=0;
 129   1          _Nop();
 130   1          _Nop();
 131   1      }
 132          
 133          
 134          
 135          
 136          
 137          
 138          /*******************************************************************
 139                           字节数据传送函数               
 140          函数原型: uchar  RcvByte();
 141          功能:  用来接收从器件传来的数据,并判断总线错误(不发应答信号)，
 142               发完后请用应答函数。  
 143          ********************************************************************/   
 144          uchar  RcvByte()
 145          {
 146   1        uchar retc;
 147   1        uchar BitCnt;
 148   1        
 149   1        retc=0; 
 150   1        SDA=1;             /*置数据线为输入方式*/
 151   1        for(BitCnt=0;BitCnt<8;BitCnt++)
 152   1            {
 153   2              _Nop();           
 154   2              SCL=0;       /*置时钟线为低，准备接收数据位*/
 155   2              _Nop();
 156   2              _Nop();         /*时钟低电平周期大于4.7μs*/
 157   2              _Nop();
 158   2              _Nop();
 159   2              _Nop();
 160   2              SCL=1;       /*置时钟线为高使数据线上数据有效*/
 161   2              _Nop();
 162   2              _Nop();
 163   2              retc=retc<<1;
 164   2              if(SDA==1)retc=retc+1; /*读数据位,接收的数据位放入retc中 */
 165   2              _Nop();
 166   2              _Nop(); 
 167   2            }
 168   1        SCL=0;    
 169   1        _Nop();
 170   1        _Nop();
 171   1        return(retc);
 172   1      }
 173          
 174          
 175          
 176          
 177          /********************************************************************
 178                               应答子函数
 179          原型:  void Ack_I2c(bit a);
C51 COMPILER V6.23a  VIIC_C51                                                              03/28/2011 00:21:22 PAGE 4   

 180           
 181          功能:主控器进行应答信号,(可以是应答或非应答信号)
 182          ********************************************************************/
 183          void Ack_I2c(bit a)
 184          {
 185   1        
 186   1        if(a==0)SDA=0;     /*在此发出应答或非应答信号 */
 187   1              else SDA=1;
 188   1        _Nop();
 189   1        _Nop();
 190   1        _Nop();      
 191   1        SCL=1;
 192   1          _Nop();
 193   1          _Nop();              /*时钟低电平周期大于4μs*/
 194   1          _Nop();
 195   1          _Nop();
 196   1          _Nop();  
 197   1       SCL=0;                /*清时钟线，钳住I2C总线以便继续接收*/
 198   1          _Nop();
 199   1          _Nop();    
 200   1      }
 201          
 202          
 203          
 204          
 205          
 206          
 207          /*******************************************************************
 208                              向无子地址器件发送字节数据函数               
 209          函数原型: bit  ISendByte(uchar sla,ucahr c);  
 210          功能:     从启动总线到发送地址，数据，结束总线的全过程,从器件地址sla.
 211                     如果返回1表示操作成功，否则操作有误。
 212          注意：    使用前必须已结束总线。
 213          ********************************************************************/
 214          bit ISendByte(uchar sla,uchar c)
 215          {
 216   1         Start_I2c();               /*启动总线*/
 217   1         SendByte(sla);            /*发送器件地址*/
 218   1           if(ack==0)return(0);
 219   1         SendByte(c);               /*发送数据*/
 220   1           if(ack==0)return(0);
 221   1        Stop_I2c();                 /*结束总线*/ 
 222   1        return(1);
 223   1      }
 224          
 225          
 226          
 227          
 228          /*******************************************************************
 229                              向有子地址器件发送多字节数据函数               
 230          函数原型: bit  ISendStr(uchar sla,uchar suba,ucahr *s,uchar no);  
 231          功能:     从启动总线到发送地址，子地址,数据，结束总线的全过程,从器件
 232                    地址sla，子地址suba，发送内容是s指向的内容，发送no个字节。
 233                     如果返回1表示操作成功，否则操作有误。
 234          注意：    使用前必须已结束总线。
 235          ********************************************************************/
 236          bit ISendStr(uchar sla,uchar suba,uchar *s,uchar no)
 237          {
 238   1         uchar i;
 239   1      
 240   1         Start_I2c();               /*启动总线*/
 241   1         SendByte(sla);            /*发送器件地址*/
C51 COMPILER V6.23a  VIIC_C51                                                              03/28/2011 00:21:22 PAGE 5   

 242   1           if(ack==0)return(0);
 243   1         SendByte(suba);            /*发送器件子地址*/
 244   1           if(ack==0)return(0);
 245   1      
 246   1         for(i=0;i<no;i++)
 247   1          {   
 248   2           SendByte(*s);               /*发送数据*/
 249   2             if(ack==0)return(0);
 250   2           s++;
 251   2          } 
 252   1       Stop_I2c();                 /*结束总线*/ 
 253   1        return(1);
 254   1      }
 255          
 256          
 257          
 258          
 259          
 260          
 261          /*******************************************************************
 262                              向无子地址器件读字节数据函数               
 263          函数原型: bit  IRcvByte(uchar sla,ucahr *c);  
 264          功能:     从启动总线到发送地址，读数据，结束总线的全过程,从器件地
 265                    址sla，返回值在c.
 266                     如果返回1表示操作成功，否则操作有误。
 267          注意：    使用前必须已结束总线。
 268          ********************************************************************/
 269          bit IRcvByte(uchar sla,uchar *c)
 270          {
 271   1         Start_I2c();                /*启动总线*/
 272   1         SendByte(sla+1);           /*发送器件地址*/
 273   1           if(ack==0)return(0);
 274   1         *c=RcvByte();               /*读取数据*/
 275   1           Ack_I2c(1);               /*发送非就答位*/
 276   1        Stop_I2c();                  /*结束总线*/ 
 277   1        return(1);
 278   1      }
 279          
 280          
 281          
 282          /*******************************************************************
 283                              向有子地址器件读取多字节数据函数               
 284          函数原型: bit  ISendStr(uchar sla,uchar suba,ucahr *s,uchar no);  
 285          功能:     从启动总线到发送地址，子地址,读数据，结束总线的全过程,从器件
 286                    地址sla，子地址suba，读出的内容放入s指向的存储区，读no个字节。
 287                     如果返回1表示操作成功，否则操作有误。
 288          注意：    使用前必须已结束总线。
 289          ********************************************************************/
 290          bit IRcvStr(uchar sla,uchar suba,uchar *s,uchar no)
 291          {
 292   1         uchar i;
 293   1      
 294   1         Start_I2c();               /*启动总线*/
 295   1         SendByte(sla);            /*发送器件地址*/
 296   1           if(ack==0)return(0);
 297   1         SendByte(suba);            /*发送器件子地址*/
 298   1           if(ack==0)return(0);
 299   1      
 300   1         Start_I2c();
 301   1         SendByte(sla+1);
 302   1            if(ack==0)return(0);
 303   1      
C51 COMPILER V6.23a  VIIC_C51                                                              03/28/2011 00:21:22 PAGE 6   

 304   1         for(i=0;i<no-1;i++)
 305   1          {   
 306   2           *s=RcvByte();               /*发送数据*/
 307   2            Ack_I2c(0);                /*发送就答位*/  
 308   2           s++;
 309   2          } 
 310   1         *s=RcvByte();
 311   1          Ack_I2c(1);                 /*发送非应位*/
 312   1       Stop_I2c();                    /*结束总线*/ 
 313   1        return(1);
 314   1      }
 315          
 316          
 317          
 318          
 319          
 320          
 321                                  /*    完毕      */
 322          
 323          
 324          
 325          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    349    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      12
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
